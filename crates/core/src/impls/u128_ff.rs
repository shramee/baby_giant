use std::collections::HashMap;

use crate::BabyGiantOps;

#[derive(Clone, PartialEq, Eq)]
pub struct U128Field {
    modulus: u128,
    steps_count: u128,
    baby_steps: HashMap<u128, u128>,
}

impl U128Field {
    pub fn new(modulus: u128) -> Self {
        let steps_count = modulus.isqrt() + 1;
        Self {
            modulus,
            steps_count,
            baby_steps: HashMap::new(),
        }
    }
}

/// Implementation for u128 modular exponentiation
impl BabyGiantOps for U128Field {
    type El = u128;
    type Scalar = u128;

    fn steps_count(&self) -> Self::Scalar {
        self.steps_count
    }

    fn baby_steps(&mut self, base: &u128) {
        let mut baby_steps = HashMap::new();
        let mut current = *base;

        let mut baby_step = 0;
        while baby_step < self.steps_count {
            baby_step += 1;
            baby_steps.insert(current, baby_step);
            current = current * base % self.modulus;
        }

        self.baby_steps = baby_steps;
    }

    fn in_baby_steps(&self, base: &u128) -> Option<&Self::Scalar> {
        self.baby_steps.get(base)
    }

    fn el_operation(&self, lhs: &u128, rhs: &u128) -> u128 {
        (lhs * rhs) % self.modulus
    }

    fn gaint_step_jump(&self, base: &u128) -> u128 {
        mod_exp(*base, self.modulus - 1 - self.steps_count, self.modulus)
    }

    fn process_result(&self, baby: &u128, giant: &u128) -> u128 {
        let step_count = self.steps_count;
        giant * step_count + baby
    }
}

/// Modular exponentiation using square-and-multiply algorithm
fn mod_exp(base: u128, exponent: u128, modulus: u128) -> u128 {
    if modulus == 1 {
        return 0;
    }

    let mut result = 1;
    let mut base = base % modulus;
    let mut exp = exponent;

    while exp > 0 {
        if exp % 2 == 1 {
            result = (result * base) % modulus;
        }
        exp >>= 1;
        base = (base * base) % modulus;
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    fn test_nums(base: u128, pow: u128, modulo: u128) {
        let mut field = U128Field::new(modulo);
        let res = mod_exp(base, pow, modulo);

        assert_eq!(field.run(base, res), Some(pow));
    }

    #[test]
    fn test_mod_exp() {
        assert_eq!(mod_exp(2, 10, 1000), 24);
        assert_eq!(mod_exp(3, 7, 13), 3);
        assert_eq!(mod_exp(7, 13, 11), 2);
    }

    #[test]
    fn test_baby_step_giant_step_small_values() {
        test_nums(3, 4, 7);
        test_nums(3, 13, 17);
    }

    #[test]
    fn test_baby_step_giant_step_larger_values() {
        test_nums(22, 109, 227);
        test_nums(22, 110, 227);
        test_nums(22, 111, 227);
    }

    #[test]
    fn test_no_solution() {
        let mut field = U128Field::new(11);
        // 3^x â‰¡ 10 (mod 11)
        // There is no solution since 10 is not in the group generated by 3 mod 11
        let result = field.run(3, 10);
        assert_eq!(result, None);
    }

    #[test]
    fn test_large_values() {
        test_nums(109768395, 121383451, 716982481063);
    }
}
